Performance related questions:
x Should build jobs be executed on a build queue, to ensure one build at a time?
* Should builds be executed on a separate process from the uspace?

Incremental downloads & builds:
* Incremental downloads will currently work if the data feed supports it
  (i.e. by providing some way to request only updates since the previous request)
* Incremental downloads must present only data new since the previous download to the build script:
  - the download script may store a complete record of all feed data, but the build script should
    only build the 'new' data.
* An incremental build works as follows:
  - Copy the full result of the previous build to the output dir
  - Perform the (partial) build on the new download data
* The publisher works exactly as it currently does.

The purpose of an incremental build is efficiency: To avoid rebuilding content when most of it remains
unchanged from build to build.

One of two possible additions to semo-build would provide full support for incremental builds:
1 Allow a feed to be marked as 'incremental: true'; the builder will then copy the previous build to
  the output dir before invoking the build script.
2 Add a function to the build context for copying files from the previous build.

Option (1) would seem to be the best one.

A further enhancement would allow downloads/builds to be trigged by the source data feed, in order to
reduce the latency between data being updated in the feed and being published to the app. This would
work as follows:
* The publisher exposes an additional HTTP URL which, when called, triggers the download and build of
  a specified feed.
* The source data feed would request this URL when it has new data.
* The URL would need appropriate access controls to prevent misuse.
* Feeds using this scheme would no longer need scheduled downloads/builds.
* The scheme could be extended to allow the source feed to submit the actual data that has been updated;
  but this approach might be brittle, as a failure to deliver the notification could result in missing
  data. For this approach to work reliably the component on the data feed side would have to track
  precisely all data items not yet delivered to the publisher, and ensure that they are eventually
  delivered.

Components:
* Components are the current Content/File objects and extensions
* Components have an html property with the following behaviour and properties:
    html()                  Returns the component's <body> html
    html.body()             Same as html()
    html.head()             Returns the component's <head> html. Generated by template from the following items:
        html.head.meta      Returns a list of meta tags
        html.head.link      Returns a list of link tags
        html.head.css       Returns the component's css as either (1) a string or (2) an object.
        html.head.script    Returns the component's JS script as a string, or an object describing an import.
* Components support automatic aggregation of support resources (i.e. js, css etc.). This works as follows:
    - Each template context includes a semo$components global object
    - Each component is allocated a unique ID within the build cycle
    - Components are allocated and referenced within the build data as current
    - When a component's html body representation is accessed (i.e. through the html()/html.body() methods)
      then a reference to that component by ID is added to semo$components
    - Consequently, once template evaluation is complete, semo$components is the set of all components used
      within the template.
    - A $head component is added to the context by default. Its html representation is simply something like
      <!-- HEAD CONTENT HERE -->
    - When template evaluation is complete, head content for the nested components can be generated by taking
      each of the meta/link/css/script properties; merging them appropriately; and then converting to html in
      an appropriate template.
    - Finally, this html can be inserted into the template result by replacing the $head html output with the
      actual head html.
    - Alternatively, if a template is evaluated as a partial within another template (i.e as part of a component's
      evaluation), then after evaluation the semo$components from the child template can be merged into the
      components set of the parent template, allowing head representations to be transferred up to parent
      templates, and allowing components to be composed of child components.

* Refinement of above: Dust will proceed with all synchronous variables in a template, before inserting async
  values *as they are resolved*; this means a $head component can be implemented as an asynchronous variable,
  whose value doesn't become available *until the rest of the template has been evaluated*. This could allow
  an alternative mechanism for inserting the head result - although the problem then becomes one of knowing
  when the rest of the template has completed evaluation.
  (This problem could be solved by automatically appending a terminal - e.g. {$head.terminal} - to the end of
  every template when loaded; the terminal would then construct the head html and resolve any {$head} tag
  previously inserted into template being evaluated).
